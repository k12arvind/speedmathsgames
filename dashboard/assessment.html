<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Prevent browser caching -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>CLAT GK Assessment</title>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        body {
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 24px;
            position: relative;
        }

        .header-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .back-btn {
            padding: 10px 20px;
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            min-height: 44px;
        }

        .back-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
        }

        .math-btn {
            background: var(--gradient-primary);
            border: none;
            color: white;
        }

        .math-btn:hover {
            box-shadow: 0 4px 20px rgba(124, 58, 237, 0.4);
        }

        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2rem);
            margin-bottom: 8px;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 15px;
        }

        .screen {
            display: none;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            box-shadow: var(--shadow-lg);
        }

        .screen.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Selection Screen */
        .pdf-table-container {
            margin-top: 20px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .pdf-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-card);
            min-width: 500px;
        }

        .pdf-table thead {
            background: var(--gradient-primary);
            color: white;
        }

        .pdf-table th {
            padding: 14px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            white-space: nowrap;
        }

        .pdf-table td {
            padding: 14px 16px;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 14px;
        }

        .pdf-table tbody tr {
            transition: background 0.15s;
        }

        .pdf-table tbody tr:hover {
            background: var(--bg-card-hover);
        }

        .pdf-table tbody tr.selected {
            background: rgba(124, 58, 237, 0.1);
        }

        .pdf-table tbody tr.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pdf-table tbody tr:not(.disabled) {
            cursor: pointer;
        }

        .pdf-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }

        .pdf-checkbox:disabled {
            cursor: not-allowed;
        }

        .pdf-filename {
            font-weight: 600;
            color: var(--text-primary);
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .pdf-date {
            color: var(--text-secondary);
        }

        .pdf-topics {
            color: var(--text-primary);
            font-weight: 500;
        }

        .pdf-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .pdf-status.processed {
            background: rgba(16, 185, 129, 0.2);
            color: #34d399;
        }

        .pdf-status.not-processed {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .selection-info {
            margin-top: 16px;
            padding: 12px 16px;
            background: rgba(124, 58, 237, 0.1);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .selection-info-text {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .test-type-selector {
            display: flex;
            gap: 12px;
            margin-top: 24px;
            flex-wrap: wrap;
        }

        .test-type-btn {
            flex: 1;
            min-width: 140px;
            padding: 16px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-input);
            cursor: pointer;
            transition: all 0.2s;
        }

        .test-type-btn:hover {
            border-color: var(--accent-primary);
            background: var(--bg-card-hover);
        }

        .test-type-btn.selected {
            border-color: var(--accent-primary);
            background: rgba(124, 58, 237, 0.15);
            box-shadow: 0 0 20px rgba(124, 58, 237, 0.2);
        }

        .test-type-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
            font-size: 15px;
        }

        .test-type-desc {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Test Screen */
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--gray-200);
            margin-bottom: 30px;
        }

        .test-progress {
            font-size: 14px;
            color: var(--gray-600);
        }

        .test-timer {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary);
        }

        .question-card {
            margin-bottom: 30px;
        }

        .question-number {
            font-size: 14px;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 12px;
        }

        .question-text {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .question-category {
            display: inline-block;
            background: rgba(124, 58, 237, 0.15);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            color: var(--accent-primary);
            margin-bottom: 20px;
            border: 1px solid rgba(124, 58, 237, 0.3);
        }

        .choices-container {
            margin: 24px 0;
        }

        .choice-option {
            padding: 16px 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--bg-input);
        }

        .choice-option:hover {
            border-color: var(--accent-primary);
            background: var(--bg-card-hover);
        }

        .choice-option.selected {
            border-color: var(--accent-primary);
            background: rgba(124, 58, 237, 0.15);
            font-weight: 600;
        }

        .choice-option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .choice-label {
            flex: 1;
            font-size: 15px;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .choice-letter {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: var(--text-secondary);
            font-size: 14px;
            flex-shrink: 0;
        }

        .choice-option.selected .choice-letter {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .choice-option.correct {
            border-color: var(--accent-success);
            background: rgba(16, 185, 129, 0.15);
        }

        .choice-option.correct .choice-letter {
            background: var(--accent-success);
            border-color: var(--accent-success);
            color: white;
        }

        .choice-option.wrong {
            border-color: var(--accent-danger);
            background: rgba(239, 68, 68, 0.15);
        }

        .choice-option.wrong .choice-letter {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            color: white;
        }

        .choice-option.disabled {
            pointer-events: none;
            opacity: 0.7;
        }

        .answer-buttons {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-primary:disabled {
            background: var(--gray-300);
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--gray-200);
            color: var(--gray-700);
        }

        .btn-secondary:hover {
            background: var(--gray-300);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        /* Results Screen */
        .results-summary {
            text-align: center;
            padding: 40px 0;
            border-bottom: 2px solid var(--gray-200);
            margin-bottom: 30px;
        }

        .score-circle {
            width: 180px;
            height: 180px;
            margin: 0 auto 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: 700;
            border: 8px solid;
        }

        .score-circle.excellent {
            border-color: var(--success);
            color: var(--success);
            background: #d1fae5;
        }

        .score-circle.good {
            border-color: var(--primary);
            color: var(--primary);
            background: #dbeafe;
        }

        .score-circle.fair {
            border-color: var(--warning);
            color: var(--warning);
            background: #fef3c7;
        }

        .score-circle.poor {
            border-color: var(--danger);
            color: var(--danger);
            background: #fee2e2;
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-box {
            text-align: center;
            padding: 20px;
            background: var(--gray-50);
            border-radius: 8px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 14px;
            color: var(--gray-600);
        }

        .review-section {
            margin-top: 30px;
        }

        .review-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .review-item {
            border: 2px solid var(--gray-200);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .review-item.correct {
            border-color: var(--success);
            background: #f0fdf4;
        }

        .review-item.wrong {
            border-color: var(--danger);
            background: #fef2f2;
        }

        .review-question {
            font-weight: 600;
            margin-bottom: 12px;
        }

        .review-answer {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .review-answer-label {
            font-weight: 600;
            margin-right: 8px;
        }

        /* Analytics Screen */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .analytics-card {
            border: 2px solid var(--gray-200);
            border-radius: 12px;
            padding: 24px;
        }

        .analytics-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .weak-question-item {
            padding: 12px;
            background: var(--gray-50);
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
        }

        .spinner {
            border: 4px solid var(--gray-200);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #fee2e2;
            color: #991b1b;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .back-btn {
            margin-bottom: 24px;
            display: inline-block;
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
            cursor: pointer;
        }

        .back-btn:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-buttons">
                <a href="comprehensive_dashboard.html" class="back-btn">‚Üê Back to Dashboard</a>
                <a href="/index.html" class="back-btn math-btn">üî¢ Switch to Math</a>
            </div>
            <h1>üéØ CLAT GK Assessment</h1>
            <p id="header-subtitle">Test your knowledge and track progress</p>
        </div>

        <!-- Screen 1: Test Selection -->
        <div id="selection-screen" class="screen active">
            <h2>Test Type</h2>
            <div class="test-type-selector">
                <div class="test-type-btn selected" data-type="full">
                    <div class="test-type-title">üìù Full Test</div>
                    <div class="test-type-desc">All questions</div>
                </div>
                <div class="test-type-btn" data-type="quick">
                    <div class="test-type-title">‚ö° Quick Test</div>
                    <div class="test-type-desc">10 random questions</div>
                </div>
                <div class="test-type-btn" data-type="weak">
                    <div class="test-type-title">üí™ Weak Topics</div>
                    <div class="test-type-desc">Practice weak areas</div>
                </div>
            </div>

            <div style="margin-top: 30px; text-align: center;">
                <button class="btn btn-primary" onclick="startTest()" id="start-btn" disabled>
                    Start Test ‚Üí
                </button>
            </div>

            <h2 style="margin-top: 40px;">Select PDFs to Test</h2>
            <p style="color: var(--gray-600); margin-bottom: 20px; text-align: center;">
                üí° Check multiple PDFs to combine questions. Only processed PDFs can be tested.
            </p>
            <div id="pdf-list">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading PDFs...</p>
                </div>
            </div>
            <div id="selection-info" class="selection-info" style="display: none;">
                <span class="selection-info-text"><span id="selected-count">0</span> PDF(s) selected</span>
                <button class="btn btn-sm" onclick="clearSelection()" style="background: var(--gray-500); padding: 6px 12px; font-size: 12px;">Clear All</button>
            </div>
        </div>

        <!-- Screen 2: Test Taking -->
        <div id="test-screen" class="screen">
            <span class="back-btn" onclick="confirmExit()">‚Üê Exit Test</span>
            <button onclick="downloadLogs()" style="position: absolute; top: 10px; right: 10px; padding: 8px 12px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer; font-size: 12px;">
                üì• Download Debug Logs
            </button>

            <div class="test-header">
                <div class="test-progress">
                    Question <span id="current-q">1</span> of <span id="total-q">10</span>
                </div>
                <div class="test-timer" id="timer">00:00</div>
            </div>

            <div class="question-card">
                <div class="question-number">Question <span id="q-num">1</span></div>
                <div class="question-category" id="q-category">Category</div>
                <div class="question-text" id="q-text">Loading question...</div>

                <!-- Multiple choice options -->
                <div class="choices-container" id="choices-container">
                    <!-- Choices will be inserted here dynamically -->
                </div>

                <div class="answer-buttons">
                    <button class="btn btn-secondary" onclick="skipQuestion()">
                        Skip ‚Üí
                    </button>
                    <button class="btn btn-primary" id="submit-answer-btn" onclick="submitAnswer()">
                        Submit Answer
                    </button>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-success" onclick="finishTest()" id="finish-btn" style="display: none;">
                    Finish Test
                </button>
            </div>
        </div>

        <!-- Screen 3: Results -->
        <div id="results-screen" class="screen">
            <span class="back-btn" onclick="showScreen('selection-screen')">‚Üê New Test</span>

            <div class="results-summary">
                <div class="score-circle excellent" id="score-circle">
                    <span id="score-display">85%</span>
                </div>
                <h2 id="results-message">Excellent Work!</h2>
                <p style="color: var(--gray-600); margin-top: 8px;">Test completed on <span id="test-date"></span></p>
            </div>

            <div class="results-stats">
                <div class="stat-box">
                    <div class="stat-value" style="color: var(--success);" id="correct-count">0</div>
                    <div class="stat-label">Correct</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" style="color: var(--danger);" id="wrong-count">0</div>
                    <div class="stat-label">Wrong</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" style="color: var(--gray-500);" id="time-taken">0m</div>
                    <div class="stat-label">Time Taken</div>
                </div>
            </div>

            <div class="review-section" id="review-section">
                <h3 class="review-title">Review Answers</h3>
                <div id="review-list"></div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-primary" onclick="showAnalytics()">
                    View Analytics ‚Üí
                </button>
                <button class="btn btn-secondary" onclick="showScreen('selection-screen')" style="margin-left: 12px;">
                    Take Another Test
                </button>
            </div>
        </div>

        <!-- Screen 4: Analytics -->
        <div id="analytics-screen" class="screen">
            <span class="back-btn" onclick="showScreen('selection-screen')">‚Üê Back</span>

            <h2>Performance Analytics</h2>
            <p style="color: var(--gray-600); margin-bottom: 30px;">Your learning insights and progress</p>

            <div class="analytics-grid">
                <div class="analytics-card">
                    <div class="analytics-title">üìä Overall Stats</div>
                    <div id="overall-stats">Loading...</div>
                </div>

                <div class="analytics-card">
                    <div class="analytics-title">üí™ Weak Questions</div>
                    <div id="weak-questions-list">Loading...</div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-primary" onclick="practiceWeakQuestions()">
                    Practice Weak Questions
                </button>
                <button class="btn btn-secondary" onclick="showScreen('selection-screen')" style="margin-left: 12px;">
                    Back to Tests
                </button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = window.location.origin;
        const DASHBOARD_API = window.location.origin;
        const ASSESSMENT_API = window.location.origin;
        let USER_ID = 'daughter';  // Default, will be updated from auth

        // Initialize user from auth
        async function initUser() {
            try {
                const response = await fetch(`${API_BASE}/auth/user`);
                if (response.ok) {
                    const user = await response.json();
                    USER_ID = user.user_id || 'daughter';
                    console.log('User loaded for assessment:', USER_ID);
                }
            } catch (e) {
                console.log('Auth not available, using default user');
            }
        }

        // State
        let selectedPdfs = [];  // Array of selected PDF IDs
        let selectedTestType = 'full';
        let currentSession = null;
        let questions = [];
        let currentQuestionIndex = 0;
        let answers = [];
        let testStartTime = null;
        let timerInterval = null;
        let allQuestions = [];  // Store all questions as they load
        let isLoadingMoreQuestions = false;
        let backgroundLoadComplete = false;
        let isSubmitting = false;  // Prevent multiple submissions
        let submitTimeoutId = null;  // Track the timeout to prevent multiple timeouts
        let lastSubmitTime = 0;  // Track last submit time for debouncing
        let debugLogs = [];  // Store all debug logs
        let isWaitingForNextQuestion = false;  // Track if we're showing feedback and waiting for "Next Question" click

        // Debug logging function
        function debugLog(message, data = null) {
            const timestamp = new Date().toISOString();
            const logEntry = {
                timestamp,
                message,
                data,
                isSubmitting,
                submitTimeoutId,
                lastSubmitTime,
                currentQuestionIndex
            };
            debugLogs.push(logEntry);

            console.log(`[${timestamp}] ${message}`, data || '');

            // Keep only last 100 logs to prevent memory issues
            if (debugLogs.length > 100) {
                debugLogs.shift();
            }
        }

        // Function to download logs
        function downloadLogs() {
            const logContent = debugLogs.map(log => {
                return `[${log.timestamp}] ${log.message}\n` +
                       `  isSubmitting: ${log.isSubmitting}\n` +
                       `  submitTimeoutId: ${log.submitTimeoutId}\n` +
                       `  lastSubmitTime: ${log.lastSubmitTime}\n` +
                       `  currentQuestionIndex: ${log.currentQuestionIndex}\n` +
                       (log.data ? `  Data: ${JSON.stringify(log.data)}\n` : '') +
                       '\n';
            }).join('');

            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `assessment-debug-${Date.now()}.log`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add keyboard shortcut to download logs (Ctrl+Shift+L)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                downloadLogs();
                alert('Debug logs downloaded! Check your Downloads folder.');
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await initUser();  // Get current user first
            await loadPdfs();
            setupTestTypeSelector();
            checkAnkiConnection();
            handleUrlParameters();

            // Add explicit click listener for debugging
            const startBtn = document.getElementById('start-btn');
            console.log('=== BUTTON SETUP ===');
            console.log('Button found:', startBtn);
            console.log('Button onclick:', startBtn.onclick);

            startBtn.addEventListener('click', function(e) {
                console.log('');
                console.log('=== BUTTON CLICK EVENT FIRED ===');
                console.log('Event:', e);
                console.log('Button disabled:', this.disabled);
                console.log('Calling startTest()...');
            });

            // Verify startTest function exists
            console.log('startTest function defined:', typeof startTest);
            console.log('startTest:', startTest);
        });

        // Handle URL parameters (for direct PDF selection from dashboard)
        async function handleUrlParameters() {
            console.log('=== HANDLING URL PARAMETERS ===');
            const urlParams = new URLSearchParams(window.location.search);
            const pdfId = urlParams.get('pdf_id');
            const filename = urlParams.get('filename');

            console.log('URL pdfId:', pdfId);
            console.log('URL filename:', filename);

            if (pdfId && filename) {
                // Update header subtitle
                document.getElementById('header-subtitle').textContent = `Testing: ${filename}`;

                // Check ACTUAL assessment status via API (don't rely on checkbox state)
                try {
                    const cacheBuster = `?_=${Date.now()}`;
                    const response = await fetch(`${API_BASE}/api/assessment-status/${encodeURIComponent(filename)}${cacheBuster}`);
                    const status = await response.json();
                    
                    console.log('Assessment status for URL PDF:', status);
                    
                    const hasQuestions = status.total_cards > 0;
                    
                    if (hasQuestions) {
                        // PDF has questions - select it using FILENAME (that's how questions are stored)
                        selectedPdfs = [filename];
                        console.log('PDF has questions, selecting by filename:', filename);
                        
                        // Wait for table to render then check the checkbox
                        setTimeout(() => {
                            // Find checkbox by filename attribute
                            const checkbox = document.querySelector(`.pdf-checkbox[data-filename="${filename}"]`);
                            if (checkbox) {
                                checkbox.disabled = false;
                                checkbox.checked = true;
                                const row = checkbox.closest('tr');
                                if (row) {
                                    row.classList.remove('disabled');
                                    row.classList.add('selected');
                                }
                            }
                            updateSelectionUI();
                        }, 500);
                    } else {
                        // PDF has no questions
                        console.log('PDF has no questions:', filename);
                        selectedPdfs = [];
                        alert(`"${filename}" has not been processed yet.\n\nPlease:\n1. Go back to dashboard\n2. Click "Create Assessment" for this PDF\n3. Then come back to take the test`);
                        updateSelectionUI();
                    }
                } catch (error) {
                    console.error('Failed to check URL PDF status:', error);
                    selectedPdfs = [];
                    updateSelectionUI();
                }
            } else {
                console.log('No URL parameters found');
            }
        }

        // Check Anki connection
        async function checkAnkiConnection() {
            try {
                const response = await fetch(`${ASSESSMENT_API}/api/assessment/check-anki`);
                const data = await response.json();
                if (!data.available) {
                    alert('‚ö†Ô∏è Anki is not running. Please start Anki to take tests.');
                }
            } catch (error) {
                console.error('Failed to check Anki:', error);
            }
        }

        // Load PDFs
        async function loadPdfs() {
            try {
                const response = await fetch(`${DASHBOARD_API}/api/pdfs/all`);
                const data = await response.json();

                const container = document.getElementById('pdf-list');

                if (data.pdfs.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: var(--gray-500);">No PDFs found</p>';
                    return;
                }

                container.innerHTML = `
                    <div class="pdf-table-container">
                        <table class="pdf-table">
                            <thead>
                                <tr>
                                    <th style="width: 40px;">
                                        <input type="checkbox" id="select-all" class="pdf-checkbox" onchange="toggleSelectAll(this)">
                                    </th>
                                    <th>PDF Name</th>
                                    <th style="width: 120px;">Date</th>
                                    <th style="width: 100px;">Questions</th>
                                    <th style="width: 90px;">Attempts</th>
                                    <th style="width: 120px;">Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${data.pdfs.map(pdf => `
                                    <tr class="disabled" data-pdf-id="${pdf.pdf_id}" data-filename="${pdf.filename}">
                                        <td onclick="event.stopPropagation();">
                                            <input type="checkbox"
                                                   class="pdf-checkbox"
                                                   data-pdf-id="${pdf.pdf_id}"
                                                   data-filename="${pdf.filename}"
                                                   disabled
                                                   onchange="handleCheckboxChange('${pdf.filename}', this)">
                                        </td>
                                        <td class="pdf-filename" title="${pdf.filename}">${pdf.filename}</td>
                                        <td class="pdf-date">${formatDate(pdf.date_published)}</td>
                                        <td class="pdf-topics" id="questions-${pdf.pdf_id}">${pdf.local_questions_count || 0}</td>
                                        <td class="pdf-attempts" style="text-align: center; font-weight: 600; color: ${pdf.assessment_attempts > 0 ? '#10b981' : '#6b7280'};">
                                            ${pdf.assessment_attempts || 0}√ó
                                        </td>
                                        <td>
                                            <span class="pdf-status" id="status-${pdf.pdf_id}">
                                                ${pdf.local_questions_count > 0 ? `‚úì ${pdf.local_questions_count} cards` : '‚è≥ Checking...'}
                                            </span>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;

                // Check assessment status for each PDF
                data.pdfs.forEach(pdf => {
                    checkAssessmentStatusForPDF(pdf);
                });
            } catch (error) {
                console.error('Failed to load PDFs:', error);
                document.getElementById('pdf-list').innerHTML =
                    '<div class="error-message">Failed to load PDFs. Please refresh the page.</div>';
            }
        }

        // Check assessment status and update badge
        async function checkAssessmentStatusForPDF(pdf) {
            try {
                // Add timestamp to prevent caching
                const cacheBuster = `?_=${Date.now()}`;
                const response = await fetch(`${API_BASE}/api/assessment-status/${encodeURIComponent(pdf.filename)}${cacheBuster}`);
                const status = await response.json();

                const statusElement = document.getElementById(`status-${pdf.pdf_id}`);
                const questionsElement = document.getElementById(`questions-${pdf.pdf_id}`);
                const checkbox = document.querySelector(`.pdf-checkbox[data-pdf-id="${pdf.pdf_id}"]`);
                const row = checkbox ? checkbox.closest('tr') : null;
                
                if (!statusElement) return;

                // Determine if PDF can be tested (has questions)
                const hasQuestions = status.total_cards > 0;
                const isProcessed = hasQuestions || (status.all_complete && pdf.exists_in_db);

                // Update Questions column with actual card count
                if (questionsElement && status.total_cards > 0) {
                    questionsElement.textContent = status.total_cards;
                }

                // Update checkbox enabled/disabled state based on actual questions
                if (checkbox) {
                    if (hasQuestions) {
                        // Has questions - enable checkbox
                        checkbox.disabled = false;
                        if (row) {
                            row.classList.remove('disabled');
                            row.onclick = () => togglePdfRow(row, pdf.filename);  // Use filename!
                        }
                    } else {
                        // No questions - disable checkbox
                        checkbox.disabled = true;
                        checkbox.checked = false;
                        if (row) {
                            row.classList.add('disabled');
                            row.onclick = null;
                        }
                        // Remove from selectedPdfs if was selected
                        if (selectedPdfs.includes(pdf.filename)) {
                            selectedPdfs = selectedPdfs.filter(id => id !== pdf.filename);
                            updateSelectionUI();
                        }
                    }
                }

                // Update status badge
                if (hasQuestions) {
                    statusElement.className = 'pdf-status processed';
                    statusElement.innerHTML = `‚úì ${status.total_cards} cards`;
                } else if (status.has_assessments) {
                    statusElement.className = 'pdf-status in-progress';
                    statusElement.innerHTML = `‚è≥ ${status.completed_chunks}/${status.total_chunks}`;
                } else {
                    statusElement.className = 'pdf-status not-processed';
                    statusElement.innerHTML = '‚ö† Not Processed';
                }
            } catch (error) {
                console.error(`Failed to check assessment status for ${pdf.filename}:`, error);
            }
        }

        // Format date
        function formatDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        }

        // Handle checkbox change
        function handleCheckboxChange(pdfId, checkbox) {
            if (checkbox.checked) {
                if (!selectedPdfs.includes(pdfId)) {
                    selectedPdfs.push(pdfId);
                }
                checkbox.closest('tr').classList.add('selected');
            } else {
                selectedPdfs = selectedPdfs.filter(id => id !== pdfId);
                checkbox.closest('tr').classList.remove('selected');
            }

            updateSelectionUI();
        }

        // Toggle PDF row
        function togglePdfRow(row, pdfId) {
            const checkbox = row.querySelector('.pdf-checkbox');
            if (!checkbox.disabled) {
                checkbox.checked = !checkbox.checked;
                handleCheckboxChange(pdfId, checkbox);
            }
        }

        // Toggle select all
        function toggleSelectAll(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('.pdf-checkbox:not(#select-all):not(:disabled)');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
                // Use filename (stored in data-filename attribute) for selections
                const filename = checkbox.getAttribute('data-filename');
                handleCheckboxChange(filename, checkbox);
            });
        }

        // Clear selection
        function clearSelection() {
            selectedPdfs = [];
            document.querySelectorAll('.pdf-checkbox').forEach(cb => cb.checked = false);
            document.querySelectorAll('.pdf-table tbody tr').forEach(row => row.classList.remove('selected'));
            updateSelectionUI();
        }

        // Update selection UI
        function updateSelectionUI() {
            const count = selectedPdfs.length;
            document.getElementById('selected-count').textContent = count;
            document.getElementById('selection-info').style.display = count > 0 ? 'flex' : 'none';
            document.getElementById('start-btn').disabled = count === 0;

            // Update select-all checkbox
            const selectAll = document.getElementById('select-all');
            if (selectAll) {
                const enabledCheckboxes = document.querySelectorAll('.pdf-checkbox:not(#select-all):not(:disabled)');
                const checkedCheckboxes = document.querySelectorAll('.pdf-checkbox:not(#select-all):not(:disabled):checked');
                selectAll.checked = enabledCheckboxes.length > 0 && enabledCheckboxes.length === checkedCheckboxes.length;
                selectAll.indeterminate = checkedCheckboxes.length > 0 && checkedCheckboxes.length < enabledCheckboxes.length;
            }
        }

        // Setup test type selector
        function setupTestTypeSelector() {
            document.querySelectorAll('.test-type-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.test-type-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedTestType = this.dataset.type;
                });
            });
        }

        // Start test
        async function startTest() {
            console.log('');
            console.log('=== START TEST CLICKED ===');
            console.log('selectedPdfs:', selectedPdfs);
            console.log('selectedTestType:', selectedTestType);

            const startBtn = document.getElementById('start-btn');
            console.log('Button disabled state:', startBtn.disabled);
            console.log('Button element:', startBtn);

            if (selectedPdfs.length === 0) {
                console.error('No PDF selected!');
                alert('Please select a PDF first');
                return;
            }

            // Get the first selected PDF filename (questions are stored by filename)
            const selectedPdf = selectedPdfs[0];
            console.log('Using PDF filename:', selectedPdf);

            console.log('Switching to test screen...');
            showScreen('test-screen');
            document.getElementById('header-subtitle').textContent = 'Good luck! üçÄ';

            try {
                const requestBody = {
                    user_id: USER_ID,
                    pdf_id: selectedPdf,
                    pdf_filename: selectedPdf,
                    source_date: selectedPdf,
                    session_type: selectedTestType
                };

                console.log('Creating test session with:', requestBody);
                console.log('API URL:', `${ASSESSMENT_API}/api/assessment/session/create`);

                // Create test session
                console.log('About to fetch...');
                console.log('Note: This may take 20-30 seconds to generate multiple choice options...');

                // Add loading message
                document.getElementById('q-text').textContent = 'Loading questions from database... ‚è≥\nFirst time may take 30-60 seconds to generate choices.';

                // Request all questions (cached in database after first generation)
                requestBody.initial_batch = false;

                const response = await fetch(`${ASSESSMENT_API}/api/assessment/session/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: AbortSignal.timeout(120000) // 2 minute timeout (first time generation takes longer)
                });

                console.log('Fetch completed!');
                console.log('Response status:', response.status);
                console.log('Response object:', response);

                console.log('About to parse JSON...');
                const data = await response.json();
                console.log('JSON parsed!');
                console.log('Response data:', data);
                console.log('data.questions:', data.questions);
                console.log('data.questions.length:', data.questions ? data.questions.length : 'undefined');

                if (data.error) {
                    alert('Error: ' + data.error);
                    showScreen('selection-screen');
                    return;
                }

                currentSession = data.session_id;
                allQuestions = data.questions;
                questions = data.questions;
                backgroundLoadComplete = true;  // All questions loaded immediately from database!

                console.log('‚úÖ All questions loaded from database:', questions.length);
                console.log('Total questions:', data.total_questions);

                // Shuffle questions for random order (always shuffle for full test)
                console.log('Shuffling questions for random order...');
                questions = questions.sort(() => 0.5 - Math.random());
                console.log('Questions shuffled');

                // Handle test type
                if (selectedTestType === 'quick') {
                    // Take first 10 from shuffled questions
                    questions = questions.slice(0, 10);
                    console.log('Quick test: Using first 10 shuffled questions');
                }

                // Reset state
                currentQuestionIndex = 0;
                answers = [];
                testStartTime = Date.now();

                // Update UI with actual question count
                const actualQuestionCount = questions.length;
                document.getElementById('total-q').textContent = actualQuestionCount;
                console.log('Test will have', actualQuestionCount, 'questions');

                // Start timer
                startTimer();

                // Show first question
                showQuestion();

            } catch (error) {
                console.error('=== ERROR CAUGHT ===');
                console.error('Error object:', error);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                alert('Failed to start test. Error: ' + error.message);
                showScreen('selection-screen');
            }
        }

        // Show question
        function showQuestion() {
            debugLog('=== SHOW QUESTION CALLED ===', {
                questionsLength: questions ? questions.length : 'undefined',
                currentQuestionIndex
            });

            if (!questions || questions.length === 0) {
                debugLog('ERROR: No questions available');
                alert('No questions loaded. Please try again.');
                showScreen('selection-screen');
                return;
            }

            if (currentQuestionIndex >= questions.length) {
                debugLog('Test complete, calling finishTest()');
                finishTest();
                return;
            }

            const question = questions[currentQuestionIndex];
            debugLog('Rendering question', { questionIndex: currentQuestionIndex });

            document.getElementById('current-q').textContent = currentQuestionIndex + 1;
            document.getElementById('q-num').textContent = currentQuestionIndex + 1;
            document.getElementById('q-category').textContent = question.category;
            document.getElementById('q-text').textContent = question.question;

            // Render multiple choice options
            const choicesContainer = document.getElementById('choices-container');
            choicesContainer.innerHTML = '';

            const letters = ['A', 'B', 'C', 'D'];
            question.choices.forEach((choice, index) => {
                const choiceDiv = document.createElement('div');
                choiceDiv.className = 'choice-option';
                choiceDiv.onclick = () => selectChoice(index);
                choiceDiv.innerHTML = `
                    <div class="choice-letter">${letters[index]}</div>
                    <div class="choice-label">${choice}</div>
                    <input type="radio" name="answer" value="${index}" style="display: none;">
                `;
                choicesContainer.appendChild(choiceDiv);
            });

            // CRITICAL: Ensure buttons are enabled and in correct state for new question
            const submitBtn = document.getElementById('submit-answer-btn');
            const skipBtn = document.querySelector('.btn-secondary');
            if (submitBtn) {
                submitBtn.textContent = 'Submit Answer';  // Reset button text
                submitBtn.disabled = false;
                submitBtn.style.opacity = '1';
                submitBtn.style.pointerEvents = 'auto';
                isWaitingForNextQuestion = false;  // Reset the flag
                debugLog('Submit button re-enabled and reset to "Submit Answer"');
            } else {
                debugLog('WARNING: Submit button not found');
            }
            if (skipBtn) {
                skipBtn.disabled = false;
                skipBtn.style.opacity = '1';
                skipBtn.style.pointerEvents = 'auto';
                debugLog('Skip button re-enabled');
            } else {
                debugLog('WARNING: Skip button not found');
            }

            // Show finish button on last question
            if (currentQuestionIndex === questions.length - 1) {
                document.getElementById('finish-btn').style.display = 'block';
                debugLog('Finish button displayed (last question)');
            }

            debugLog('=== SHOW QUESTION COMPLETED ===');
        }

        // Select a choice
        function selectChoice(index) {
            // Remove previous selection
            document.querySelectorAll('.choice-option').forEach(opt => {
                opt.classList.remove('selected');
            });

            // Select this one
            const choiceOptions = document.querySelectorAll('.choice-option');
            choiceOptions[index].classList.add('selected');
            choiceOptions[index].querySelector('input[type="radio"]').checked = true;
        }

        // Submit answer (also handles "Next Question" click)
        async function submitAnswer() {
            debugLog('=== BUTTON CLICKED ===', { isWaitingForNextQuestion });

            // If we're in "Next Question" mode, advance to next question
            if (isWaitingForNextQuestion) {
                debugLog('Next Question mode - advancing to next question');
                isWaitingForNextQuestion = false;

                // Check if we need to wait for background loading
                if (currentQuestionIndex >= allQuestions.length && !backgroundLoadComplete) {
                    document.getElementById('q-text').textContent = 'Loading next questions... ‚è≥';
                    await waitForBackgroundLoad();
                }

                // Reset button text
                const submitBtn = document.getElementById('submit-answer-btn');
                submitBtn.textContent = 'Submit Answer';
                debugLog('Button text reset to "Submit Answer"');

                // Show next question
                showQuestion();
                return;
            }

            debugLog('=== SUBMIT ANSWER MODE ===');

            // Debounce check - prevent clicks within 500ms of last submit
            const now = Date.now();
            const timeSinceLastSubmit = now - lastSubmitTime;

            if (timeSinceLastSubmit < 500) {
                debugLog('BLOCKED: Debounce check failed', { timeSinceLastSubmit });
                return;
            }

            // Prevent multiple submissions - CRITICAL CHECK
            if (isSubmitting) {
                debugLog('BLOCKED: isSubmitting flag is TRUE');
                return;
            }

            // Clear any existing timeout (shouldn't happen, but safety check)
            if (submitTimeoutId) {
                debugLog('WARNING: Clearing existing timeout', { submitTimeoutId });
                clearTimeout(submitTimeoutId);
                submitTimeoutId = null;
            }

            const question = questions[currentQuestionIndex];
            debugLog('Current question retrieved', { questionIndex: currentQuestionIndex });

            // Get selected choice
            const selectedRadio = document.querySelector('input[name="answer"]:checked');

            if (!selectedRadio) {
                debugLog('BLOCKED: No answer selected');
                alert('Please select an answer');
                return;
            }

            // Set submitting flag IMMEDIATELY to block any further calls
            isSubmitting = true;
            lastSubmitTime = now;
            debugLog('FLAGS SET: isSubmitting=TRUE, lastSubmitTime updated', {
                isSubmitting,
                lastSubmitTime
            });

            const selectedIndex = parseInt(selectedRadio.value);
            const userAnswer = question.choices[selectedIndex];
            const correctAnswer = question.answer;
            const isCorrect = (selectedIndex === question.correct_index);

            debugLog('Answer details', {
                selectedIndex,
                correctIndex: question.correct_index,
                isCorrect,
                userAnswer,
                correctAnswer
            });

            // Disable submit button during feedback and remove onclick
            const submitBtn = document.getElementById('submit-answer-btn');
            const skipBtn = document.querySelector('.btn-secondary');
            submitBtn.disabled = true;
            submitBtn.style.opacity = '0.5';
            submitBtn.style.pointerEvents = 'none';
            skipBtn.disabled = true;
            skipBtn.style.opacity = '0.5';
            skipBtn.style.pointerEvents = 'none';

            debugLog('Buttons disabled for feedback period');

            // Show instant feedback with green/red highlighting
            const choiceOptions = document.querySelectorAll('.choice-option');
            choiceOptions.forEach((opt, idx) => {
                opt.classList.add('disabled');  // Disable all choices

                if (idx === question.correct_index) {
                    // Mark correct answer in green
                    opt.classList.remove('selected');
                    opt.classList.add('correct');
                } else if (idx === selectedIndex && !isCorrect) {
                    // Mark wrong answer in red
                    opt.classList.remove('selected');
                    opt.classList.add('wrong');
                }
            });

            debugLog('Visual feedback displayed, changing button to Next Question');

            // Record answer in background (don't wait for response)
            fetch(`${ASSESSMENT_API}/api/assessment/answer/submit`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: currentSession,
                    note_id: question.note_id,
                    question: question.question,
                    correct_answer: correctAnswer,
                    user_answer: userAnswer,
                    category: question.category,
                    time_taken: Math.floor((Date.now() - testStartTime) / 1000)
                })
            }).catch(error => {
                console.error('Failed to submit answer (background):', error);
                // Don't show error to user - answer is already recorded locally
            });

            // Record answer locally (no need to wait for API)
            answers.push({
                question: question.question,
                correct_answer: correctAnswer,
                user_answer: userAnswer,
                category: question.category,
                is_correct: isCorrect
            });

            // Increment question index
            currentQuestionIndex++;

            debugLog('About to change button text', {
                currentButtonText: submitBtn.textContent,
                buttonElement: submitBtn
            });

            // Change button to "Next Question" mode
            submitBtn.textContent = 'Next Question ‚Üí';

            debugLog('Button textContent set', {
                newButtonText: submitBtn.textContent,
                verifyChange: submitBtn.textContent === 'Next Question ‚Üí'
            });

            submitBtn.disabled = false;
            submitBtn.style.opacity = '1';
            submitBtn.style.pointerEvents = 'auto';

            // Set flag so next click will advance to next question
            isWaitingForNextQuestion = true;
            isSubmitting = false;  // Reset this flag so button is clickable

            debugLog('Button changed to "Next Question ‚Üí", waiting for user click', {
                isWaitingForNextQuestion,
                isSubmitting,
                buttonText: submitBtn.textContent
            });
        }

        // Load remaining questions (waits until complete)
        async function loadRemainingQuestions(sessionId, pdfId, totalQuestions) {
            if (isLoadingMoreQuestions || backgroundLoadComplete) {
                return;
            }

            isLoadingMoreQuestions = true;
            console.log('üì• Loading all remaining questions...');

            try {
                const response = await fetch(`${ASSESSMENT_API}/api/assessment/session/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_id: USER_ID,
                        pdf_id: pdfId,
                        pdf_filename: pdfId,
                        source_date: pdfId,
                        session_type: 'full',  // Always get all questions
                        initial_batch: false  // Get all questions
                    }),
                    signal: AbortSignal.timeout(120000) // 2 minute timeout for full load
                });

                const data = await response.json();

                if (data.success && data.questions) {
                    allQuestions = data.questions;
                    console.log('‚úÖ All questions loaded! Total questions:', allQuestions.length);
                    backgroundLoadComplete = true;
                } else if (data.questions) {
                    allQuestions = data.questions;
                    console.log('‚úÖ All questions loaded! Total questions:', allQuestions.length);
                    backgroundLoadComplete = true;
                }
            } catch (error) {
                console.error('‚ùå Loading failed:', error);
                // Fall back to initial batch if loading fails
                allQuestions = questions;
                backgroundLoadComplete = true;
            } finally {
                isLoadingMoreQuestions = false;
            }
        }

        // Wait for background loading to complete
        async function waitForBackgroundLoad() {
            console.log('‚è≥ Waiting for background loading to complete...');

            const maxWait = 60000;  // 60 seconds max wait
            const startTime = Date.now();

            while (!backgroundLoadComplete && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            if (backgroundLoadComplete && allQuestions.length > questions.length) {
                questions = allQuestions;
                console.log('‚úÖ Questions updated from background load');
            }
        }

        // Skip question
        function skipQuestion() {
            const question = questions[currentQuestionIndex];

            answers.push({
                question: question.question,
                correct_answer: question.answer,
                user_answer: null,
                category: question.category
            });

            currentQuestionIndex++;
            showQuestion();
        }

        // Start timer
        function startTimer() {
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - testStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timer').textContent =
                    `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // Stop timer
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
        }

        // Finish test
        async function finishTest() {
            if (!confirm('Finish test and see results?')) return;

            stopTimer();

            // Complete session
            try {
                await fetch(`${ASSESSMENT_API}/api/assessment/session/complete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: currentSession
                    })
                });

                // Show results
                showResults();

            } catch (error) {
                console.error('Failed to complete test:', error);
                alert('Failed to complete test. Please try again.');
            }
        }

        // Show results
        function showResults() {
            showScreen('results-screen');
            document.getElementById('header-subtitle').textContent = 'Review your performance';

            // Calculate stats using the is_correct flag
            const correct = answers.filter(a => a.is_correct).length;
            const wrong = answers.filter(a => a.user_answer && !a.is_correct).length;
            const skipped = answers.filter(a => !a.user_answer).length;
            const score = Math.round((correct / answers.length) * 100);

            // Update score display
            const scoreCircle = document.getElementById('score-circle');
            const scoreDisplay = document.getElementById('score-display');
            const resultsMessage = document.getElementById('results-message');

            scoreDisplay.textContent = score + '%';

            if (score >= 80) {
                scoreCircle.className = 'score-circle excellent';
                resultsMessage.textContent = 'Excellent Work! üéâ';
            } else if (score >= 60) {
                scoreCircle.className = 'score-circle good';
                resultsMessage.textContent = 'Good Job! üëç';
            } else if (score >= 40) {
                scoreCircle.className = 'score-circle fair';
                resultsMessage.textContent = 'Keep Practicing! üí™';
            } else {
                scoreCircle.className = 'score-circle poor';
                resultsMessage.textContent = 'Need More Practice üìö';
            }

            document.getElementById('correct-count').textContent = correct;
            document.getElementById('wrong-count').textContent = wrong;
            document.getElementById('test-date').textContent = new Date().toLocaleDateString();

            const timeTaken = Math.floor((Date.now() - testStartTime) / 60000);
            document.getElementById('time-taken').textContent = timeTaken + 'm';

            // Show review with green/red highlighting
            const reviewList = document.getElementById('review-list');
            reviewList.innerHTML = answers.map((a, i) => {
                const isCorrect = a.is_correct;
                const isSkipped = !a.user_answer;

                return `
                    <div class="review-item ${isSkipped ? '' : isCorrect ? 'correct' : 'wrong'}">
                        <div class="review-question">Q${i + 1}: ${a.question}</div>
                        <div class="review-answer" style="${!isCorrect && !isSkipped ? 'color: #ef4444; font-weight: 600;' : ''}">
                            <span class="review-answer-label">Your Answer:</span>
                            ${a.user_answer || '(Skipped)'}
                        </div>
                        <div class="review-answer" style="${isCorrect ? 'color: #10b981; font-weight: 600;' : 'color: #10b981;'}">
                            <span class="review-answer-label">Correct Answer:</span>
                            ${a.correct_answer}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Check answer
        function checkAnswer(userAnswer, correctAnswer) {
            const user = userAnswer.trim().toLowerCase();
            const correct = correctAnswer.trim().toLowerCase();
            return user === correct || user.includes(correct) || correct.includes(user);
        }

        // Show analytics
        async function showAnalytics() {
            showScreen('analytics-screen');
            document.getElementById('header-subtitle').textContent = 'Track your progress';

            // Load analytics
            try {
                const response = await fetch(`${ASSESSMENT_API}/api/assessment/performance/summary?user_id=${USER_ID}`);
                const data = await response.json();

                document.getElementById('overall-stats').innerHTML = `
                    <div style="margin-bottom: 12px;"><strong>Total Tests:</strong> ${data.total_tests}</div>
                    <div style="margin-bottom: 12px;"><strong>Average Score:</strong> ${data.average_score}%</div>
                    <div><strong>Questions Attempted:</strong> ${data.total_questions_attempted}</div>
                `;

                // Load weak questions
                const weakResponse = await fetch(`${ASSESSMENT_API}/api/assessment/performance/weak-questions?user_id=${USER_ID}`);
                const weakData = await weakResponse.json();

                if (weakData.weak_questions && weakData.weak_questions.length > 0) {
                    document.getElementById('weak-questions-list').innerHTML = weakData.weak_questions.map(q => `
                        <div class="weak-question-item">
                            ${q.question_text.substring(0, 80)}...
                            <br><small style="color: var(--gray-600);">Accuracy: ${Math.round(q.accuracy)}%</small>
                        </div>
                    `).join('');
                } else {
                    document.getElementById('weak-questions-list').innerHTML =
                        '<p style="color: var(--gray-600);">No weak questions yet. Keep practicing!</p>';
                }

            } catch (error) {
                console.error('Failed to load analytics:', error);
            }
        }

        // Practice weak questions
        function practiceWeakQuestions() {
            alert('Feature coming soon! This will let you practice questions you got wrong.');
        }

        // Show screen
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        // Confirm exit
        function confirmExit() {
            if (confirm('Are you sure you want to exit? Your progress will be lost.')) {
                stopTimer();
                showScreen('selection-screen');
                document.getElementById('header-subtitle').textContent = 'Test your knowledge and track progress';
            }
        }
    </script>
</body>
</html>
